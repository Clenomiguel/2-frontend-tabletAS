// lib/utils/parsing_utils.dart
// Utilitários para parsing seguro de dados JSON do backend

class ParsingUtils {
  /// Parse seguro para int - aceita int, double ou String
  static int? parseInt(dynamic value) {
    if (value == null) return null;
    if (value is int) return value;
    if (value is double) return value.toInt();
    if (value is String) {
      return int.tryParse(value) ?? double.tryParse(value)?.toInt();
    }
    return null;
  }

  /// Parse seguro para double - aceita int, double ou String
  static double? parseDouble(dynamic value) {
    if (value == null) return null;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) {
      // Trata formato brasileiro (1.234,56) e americano (1,234.56)
      String normalized = value.replaceAll(' ', '');
      // Se tem vírgula como decimal (formato BR)
      if (normalized.contains(',') && !normalized.contains('.')) {
        normalized = normalized.replaceAll(',', '.');
      } else if (normalized.contains(',') && normalized.contains('.')) {
        // Formato 1.234,56 -> 1234.56
        normalized = normalized.replaceAll('.', '').replaceAll(',', '.');
      }
      return double.tryParse(normalized);
    }
    return null;
  }

  /// Parse seguro para bool - aceita bool, int, String
  static bool? parseBool(dynamic value) {
    if (value == null) return null;
    if (value is bool) return value;
    if (value is int) return value != 0;
    if (value is String) {
      final lower = value.toLowerCase();
      if (lower == 'true' || lower == '1' || lower == 's' || lower == 'sim') {
        return true;
      }
      if (lower == 'false' ||
          lower == '0' ||
          lower == 'n' ||
          lower == 'nao' ||
          lower == 'não') {
        return false;
      }
    }
    return null;
  }

  /// Parse seguro para DateTime
  static DateTime? parseDateTime(dynamic value) {
    if (value == null) return null;
    if (value is DateTime) return value;
    if (value is String) {
      return DateTime.tryParse(value);
    }
    return null;
  }

  /// Parse seguro para List
  static List<T> parseList<T>(
    dynamic value,
    T Function(Map<String, dynamic>) fromJson,
  ) {
    if (value == null) return [];
    if (value is! List) return [];
    return value
        .whereType<Map<String, dynamic>>()
        .map((e) => fromJson(e))
        .toList();
  }

  /// Formata valor monetário para exibição
  static String formatCurrency(double? value) {
    if (value == null) return 'R\$ 0,00';
    return 'R\$ ${value.toStringAsFixed(2).replaceAll('.', ',')}';
  }

  /// Formata quantidade com unidade
  static String formatQuantity(double? quantidade, String? unidade) {
    if (quantidade == null) return '';
    final qtdStr =
        quantidade == quantidade.toInt()
            ? quantidade.toInt().toString()
            : quantidade.toStringAsFixed(2).replaceAll('.', ',');
    return unidade != null ? '$qtdStr $unidade' : qtdStr;
  }
}
