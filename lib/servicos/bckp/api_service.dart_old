// lib/services/api_service.dart
// Serviço de comunicação com o backend FastAPI

import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;

import '../models/produto_models.dart';
import '../models/cardapio_models.dart';
import '../models/cart_models.dart';

/// Exceção customizada para erros de API
class ApiException implements Exception {
  final String message;
  final int? statusCode;
  final dynamic data;

  ApiException(this.message, {this.statusCode, this.data});

  @override
  String toString() => 'ApiException: $message (status: $statusCode)';
}

/// Configuração da API
class ApiConfig {
  final String baseUrl;
  final int empresaId;
  final int totemId;
  final Duration timeout;

  const ApiConfig({
    required this.baseUrl,
    required this.empresaId,
    required this.totemId,
    this.timeout = const Duration(seconds: 30),
  });

  /// Configuração de desenvolvimento
  factory ApiConfig.dev() {
    return const ApiConfig(
      baseUrl: 'http://localhost:8000',
      empresaId: 1,
      totemId: 1,
    );
  }
}

/// Serviço principal de API
class ApiService {
  final ApiConfig config;
  final http.Client _client;

  ApiService({required this.config, http.Client? client})
    : _client = client ?? http.Client();

  /// Headers padrão para requisições
  Map<String, String> get _headers => {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  };

  /// Monta URL completa
  Uri _buildUrl(String path, [Map<String, dynamic>? queryParams]) {
    final uri = Uri.parse('${config.baseUrl}$path');
    if (queryParams != null && queryParams.isNotEmpty) {
      return uri.replace(
        queryParameters: queryParams.map(
          (key, value) => MapEntry(key, value?.toString() ?? ''),
        ),
      );
    }
    return uri;
  }

  /// GET request genérico
  Future<Map<String, dynamic>> _get(
    String path, [
    Map<String, dynamic>? queryParams,
  ]) async {
    try {
      final response = await _client
          .get(_buildUrl(path, queryParams), headers: _headers)
          .timeout(config.timeout);

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('Sem conexão com o servidor');
    } on http.ClientException catch (e) {
      throw ApiException('Erro de conexão: $e');
    }
  }

  /// POST request genérico
  Future<Map<String, dynamic>> _post(
    String path,
    Map<String, dynamic> body,
  ) async {
    try {
      final response = await _client
          .post(_buildUrl(path), headers: _headers, body: jsonEncode(body))
          .timeout(config.timeout);

      return _handleResponse(response);
    } on SocketException {
      throw ApiException('Sem conexão com o servidor');
    } on http.ClientException catch (e) {
      throw ApiException('Erro de conexão: $e');
    }
  }

  /// Processa resposta HTTP
  Map<String, dynamic> _handleResponse(http.Response response) {
    final body =
        response.body.isNotEmpty
            ? jsonDecode(response.body) as Map<String, dynamic>
            : <String, dynamic>{};

    if (response.statusCode >= 200 && response.statusCode < 300) {
      return body;
    }

    final message = body['detail'] ?? body['message'] ?? 'Erro desconhecido';
    throw ApiException(
      message.toString(),
      statusCode: response.statusCode,
      data: body,
    );
  }

  // ============================================================
  // CARDÁPIOS
  // ============================================================

  /// Busca cardápio completo por ID
  Future<CardapioCompleto> getCardapioCompleto(int cardapioId) async {
    final data = await _get('/api/cardapios/$cardapioId/completo');
    return CardapioCompleto.fromJson(data);
  }

  /// Lista cardápios da empresa
  Future<List<Cardapio>> getCardapios() async {
    final data = await _get('/api/cardapios', {'empresa_id': config.empresaId});
    final items = data['items'] as List? ?? [];
    return items.map((e) => Cardapio.fromJson(e)).toList();
  }

  /// Busca cardápio ativo do totem
  Future<CardapioCompleto?> getCardapioAtivo() async {
    try {
      final data = await _get('/api/totens/${config.totemId}/cardapio-ativo');
      return CardapioCompleto.fromJson(data);
    } on ApiException catch (e) {
      if (e.statusCode == 404) return null;
      rethrow;
    }
  }

  // ============================================================
  // PRODUTOS
  // ============================================================

  /// Busca produto completo por ID
  Future<ProdutoCompleto> getProdutoCompleto(int produtoId) async {
    final data = await _get('/api/produtos/$produtoId/completo');
    return ProdutoCompleto.fromJson(data);
  }

  /// Lista produtos paginados
  Future<PaginatedResponse<Produto>> getProdutos({
    int page = 1,
    int perPage = 100,
    String? search,
    int? grupoId,
    bool? permiteVenda,
  }) async {
    final params = <String, dynamic>{
      'empresa_id': config.empresaId,
      'page': page,
      'per_page': perPage,
    };
    if (search != null) params['search'] = search;
    if (grupoId != null) params['grupo_id'] = grupoId;
    if (permiteVenda != null) params['permite_venda'] = permiteVenda;

    final data = await _get('/api/produtos', params);
    return PaginatedResponse.fromJson(data, Produto.fromJson);
  }

  /// Busca preparos de um produto
  Future<PreparosDoProduto> getPreparosProduto(int produtoId) async {
    final data = await _get('/api/produtos/$produtoId/preparos');
    return PreparosDoProduto.fromJson(data);
  }

  /// Busca composição de um produto
  Future<List<ProdutoComposicao>> getComposicaoProduto(int produtoId) async {
    final data = await _get('/api/produtos/$produtoId/composicao');
    final items = data['items'] as List? ?? data as List? ?? [];
    return items.map((e) => ProdutoComposicao.fromJson(e)).toList();
  }

  /// Busca complementos de um produto
  Future<List<ProdutoComplemento>> getComplementosProduto(int produtoId) async {
    final data = await _get('/api/produtos/$produtoId/complementos');
    final items = data['items'] as List? ?? data as List? ?? [];
    return items.map((e) => ProdutoComplemento.fromJson(e)).toList();
  }

  // ============================================================
  // IMAGENS
  // ============================================================

  /// Monta URL da imagem do produto
  String getProdutoImageUrl(int produtoId, {String size = 'medium'}) {
    return '${config.baseUrl}/api/produtos/$produtoId/imagem?size=$size';
  }

  /// Monta URL da imagem da seção
  String getSecaoImageUrl(int secaoId, {String size = 'medium'}) {
    return '${config.baseUrl}/api/cardapios/secoes/$secaoId/imagem?size=$size';
  }

  // ============================================================
  // COMANDA
  // ============================================================

  /// Registra comanda no Linx
  Future<ComandaResponse> registrarComanda(Cart cart) async {
    final payload = cart.toComandaPayload(
      totemId: config.totemId,
      empresaId: config.empresaId,
    );

    final data = await _post('/api/comandas/registrar', payload);
    return ComandaResponse.fromJson(data);
  }

  /// Consulta status de comanda
  Future<Map<String, dynamic>> getStatusComanda(String comandaId) async {
    return await _get('/api/comandas/$comandaId/status');
  }

  // ============================================================
  // CONFIGURAÇÕES DO TOTEM
  // ============================================================

  /// Busca configurações do totem
  Future<Map<String, dynamic>> getTotemConfig() async {
    return await _get('/api/totens/${config.totemId}/config');
  }

  /// Busca informações do totem
  Future<Map<String, dynamic>> getTotemInfo() async {
    return await _get('/api/totens/${config.totemId}');
  }

  // ============================================================
  // HEALTH CHECK
  // ============================================================

  /// Verifica se o servidor está online
  Future<bool> healthCheck() async {
    try {
      await _get('/health');
      return true;
    } catch (_) {
      return false;
    }
  }

  /// Fecha conexões
  void dispose() {
    _client.close();
  }
}

/// Singleton para acesso global ao serviço
class Api {
  static ApiService? _instance;

  static void init(ApiConfig config) {
    _instance = ApiService(config: config);
  }

  static ApiService get instance {
    if (_instance == null) {
      throw StateError(
        'ApiService não inicializado. Chame Api.init() primeiro.',
      );
    }
    return _instance!;
  }

  static bool get isInitialized => _instance != null;
}
